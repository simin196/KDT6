#--------------------------------------------------------------------------
# list 
#--------------------------------------------------------------------------
# range > 객체의 정보 range로 표현된다 
# 그래서 함수로 이용해서 list와 tuple로 변경해야 사용하기 편하다.
# [10 9 8 7 ... 1] == range(10,0,-1)


# x=[1,2,3] > list 타입 >> 각각의 인덱스를 뽑아내면 각 원소의 타입이 따라온다 list아님.
# a,b,c=[1,2,3] >> a=1 b=2 c=3 ==> int 타입



#--------------------------------------------------------------------------
# dict
#--------------------------------------------------------------------------
'''
* 생성하는 방법

1. 직접입력
a={'a': 1, 'b' : 2 }

2. dict함수 사용 
b=dict(a=1, b=2) 

# lus = {'a': 400, 'b' : 380 ,'c': 270, 'd' : 100 }
# 380을 뽑고 싶은 경우 >>> lus['b']

메서드
lus.keys() >>> key값만 뽑고싶을때
lus.values() >>> value값만 뽑고싶을때
lus.items() >>> 지정된 위치 값만 뽑고싶을때 >>> 3개다 list 형식으로 만들어준다.

key가 우선적으로 취급

'''
lus = {'a': 400, 'b' : 380 ,'c': 270, 'd' : 100 }
print(lus.items())
print(lus.keys()) 

#--------------------------------------------------------------------------
# tuple
#--------------------------------------------------------------------------
# 변경, 수정 불가
# 3 == (3) >> int , (3,) > tuple
# list()처럼 range를 함수 tuple()로 만들 수 있다.



# 리터러블 객체 > 연속되는(반복되는,다음이있는) 자료형 > range, str

# 시퀀스 >1. 블변 시퀀스(str,tuple)  , 2. 변경 시퀀스(list)

# 대입연산자 '=' >>> 할당
# 비교연산자 '==' >>> True False

# del 변수[인덱스] >> 그 부분 삭제

#--------------------------------------------------------------------------
# map
#--------------------------------------------------------------------------
'''
int(str)을 사용하면 int 로 출력한다.

but
int([]) >> 리스트를 int로 변환하게 된다면 ERROR

So
map을 사용
map(사용할 함수 , 리스트[리터러블 객체] )  >>>> 리스트에 있는 값을 함수에 하나씩 대입

'''

#--------------------------------------------------------------------------
# zip
#--------------------------------------------------------------------------
'''

같은 인덱스의 두 리스트를 dict로 묶어줄수있다
앞을 key 뒤를 value로 

'''

#-------------------------------------------------------------
#
#---------------------------------------------------------------

